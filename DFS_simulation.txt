Count the number of islands in a grid (1 = land, 0 = water).
	

def numIslands(grid):
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    visited = set()

    def dfs(r, c):

        # return if out of bounds or water or already visited
        if (r < 0 or c < 0 or r >= rows or c >= cols or
            grid[r][c] == "0" or (r, c) in visited):
            return
        visited.add((r, c))

        # explore neighbors (up, down, left, right)
        dfs(r+1, c) # Down
        dfs(r-1, c) # Up
        dfs(r, c+1) # Right
        dfs(r, c-1) # Left

    count = 0
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == "1" and (r, c) not in visited:
                dfs(r, c)
                count += 1
    return count

print(numIslands([
    ["1","1","0","0"],
    ["1","0","0","1"],
    ["0","0","1","1"],
    ["0","0","0","0"]
]))


	
			  [0,0;0,1;0,2;0,3]  [1,0;1,1;1,2;1,3]  [2,0;2,1;2,2;2,3]  [3,0;3,1;3,2;3,3]
numIslands = [["1","1","0","0"], ["1","0","0","1"], ["0","0","1","1"], ["0","0","0","0"]]


SIMULATION


numIslands([
    ["1","1","0","0"],
    ["1","0","0","1"],
    ["0","0","1","1"],
    ["0","0","0","0"]
])

rows = 4, cols = 4
visited = set()

# The code starts at the for loop because def dfs explains to us what the function is going
	to do
	
1st iteration - (r=0,c=0)

# the ones that are out of bounds or water or already visited will return nothing

if grid[r][c] == "1" and (r, c) not in visited: # TRUE
	dfs(0,0)
		if (r < 0 or c < 0 or r >= rows or c >= cols or
			grid[r][c] == "0" or (r, c) in visited): # FALSE
		visited.add((0,0)) # visited = {(0,0)}

		dfs(1,0) # Down -> check this one
			if grid[r][c] == "1" and (r, c) not in visited:
				dfs(1,0)
					if (r < 0 or c < 0 or r >= rows or c >= cols or
						grid[r][c] == "0" or (r, c) in visited): # FALSE
					visited.add((1,0)) # visited = {(0,0),(1,0)}
		
					# explore neighbors of (1,0)
					dfs(2,0) # Down -> water
					dfs(0,0) # Up -> already visited
					dfs(1,1) # Right -> water
					dfs(-1,1) # Left -> out of bounds
		
		dfs(-1,0) # Up -> now this one
			# since this one is out of bounds, return nothing

		dfs(0,1) # Right
			if grid[r][c] == "1" and (r, c) not in visited: # TRUE
				dfs(0,1)
					if (r < 0 or c < 0 or r >= rows or c >= cols or
						grid[r][c] == "0" or (r, c) in visited): # FALSE
					visited.add((1,0)) # visited = {(0,0),(1,0),(0,1)}
					
					# explore neighbors of (0,1)
					dfs(1,1) # Down -> water
					dfs(-1,1) # Up -> out of bounds
					dfs(0,2) # Right -> water
					dfs(0,0) # Left -> already visited
				
		dfs(0,-1) # Left
			# out of bounds
		
After first DFS: visited = {(0,0),(1,0),(0,1)}

count += 1 # count = 1

2nd iteration - (r=0,c=1)
	dfs(0,1) # already visited
3rd iteration - (r=0,c=2)
	dfs(0,2) # water
4th iteration - (r=0,c=3)
	dfs(0,3) # water
5th iteration - (r=1,c=0)
	dfs(1,0) # already visited
6th iteration - (r=1,c=1)
	dfs(1,1) # water
7th iteration - (r=1,c=2)
	dfs(1,2) # water
	
8th iteration - (r=1,c=3)
	dfs(1,3)
		if grid[1][3] == "1" and (1,3) not in visited:  # TRUE
			dfs(1, 3)  # Start DFS from second island
				if (r < 0 or c < 0 or r >= rows or c >= cols or
					grid[r][c] == "0" or (r, c) in visited): # TRUE
				visited.add((1,0)) # visited = {(0,0),(1,0),(0,1),(1,3)}
				
				# explore neighbors of (1,3)
				dfs(2,3) # Down
					if grid[r][c] == "1" and (r, c) not in visited: # TRUE
					dfs(2,3)
						if (r < 0 or c < 0 or r >= rows or c >= cols or
							grid[r][c] == "0" or (r, c) in visited): # TRUE
						visited.add((1,0)) # visited = {(0,0),(1,0),(0,1),(1,3),(2,3)}
						
						# explore neighbors of (2,3)
						dfs(3,3) # Down -> water
						dfs(1,3) # Up -> visited
						dfs(2,4) # Right -> out of bounds
						dfs(2,2) # Left
							if (r < 0 or c < 0 or r >= rows or c >= cols or
								grid[r][c] == "0" or (r, c) in visited): # TRUE
							visited.add((1,0)) # visited = {(0,0),(1,0),(0,1),(1,3),(2,3),(2,2)}

After 2nd DFS: connected islands = {(1,3),(2,3),(2,2)}
After 2nd DFS: visited = {(0,0),(1,0),(0,1),(1,3),(2,3),(2,2)}

count += 1 # count = 2						

				dfs(0,3) # Up -> water
				dfs(1,4) # Right -> out of bounds
				dfs(1,2) # Left -> water
				
# What I'm getting from this DFS pattern is that when conditions are met (if grid[r][c] == "1"
	and (r, c) not in visited:) dfs(r,c) which is the recursive part will allow the code to explore
	one direction (DOWN) until it finds the solution (1 = land) or hits a dead-end (0 = water or
	out of bounds)